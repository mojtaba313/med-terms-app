[file content begin]
the codes of file with route : /app/api/terms/import/route.ts :
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "../../auth/[...nextauth]/route";
import prisma from "../../../../../lib/prisma";

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.email) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
    });

    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    const { globalCategories, items } = await request.json();

    if (!Array.isArray(items)) {
      return NextResponse.json(
        { error: "Items must be an array" },
        { status: 400 }
      );
    }

    const results = [];

    for (const item of items) {
      // Validate required fields
      if (!item.term || !item.meaning) {
        continue; // Skip invalid items
      }

      // Process categories - merge globalCategories with item categories
      let allCategoryNames: string[] = [];
      
      // Add global categories
      if (Array.isArray(globalCategories)) {
        allCategoryNames.push(...globalCategories);
      }
      
      // Add item-specific categories
      if (Array.isArray(item.categories)) {
        allCategoryNames.push(...item.categories);
      }
      
      // Remove duplicates
      allCategoryNames = [...new Set(allCategoryNames)];

      let categoryIds: string[] = [];
      
      for (const categoryName of allCategoryNames) {
        if (typeof categoryName !== 'string') continue;
        
        let category = await prisma.category.findFirst({
          where: { 
            name: categoryName.trim(),
            userId: user.id 
          },
        });
        
        // Create category if it doesn't exist
        if (!category) {
          category = await prisma.category.create({
            data: {
              name: categoryName.trim(),
              color: getRandomColor(),
              userId: user.id,
            },
          });
        }
        
        if (category) {
          categoryIds.push(category.id);
        }
      }

      // Create the term
      const term = await prisma.medicalTerm.create({
        data: {
          term: item.term,
          meaning: item.meaning,
          pronunciation: item.pronunciation || null,
          explanation: item.explanation || null,
          userId: user.id,
          categories: {
            connect: categoryIds.map(id => ({ id })),
          },
        },
        include: {
          categories: true,
        },
      });

      results.push(term);
    }

    return NextResponse.json({
      message: `${results.length} terms imported successfully`,
      data: results,
    });
  } catch (error) {
    console.error("Error importing terms:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

function getRandomColor() {
  const colors = [
    "#3B82F6", "#EF4444", "#10B981", "#F59E0B", "#8B5CF6",
    "#EC4899", "#06B6D4", "#84CC16", "#F97316", "#6366F1"
  ];
  return colors[Math.floor(Math.random() * colors.length)];
}
-----

the codes of file with route : /app/api/phrases/import/route.ts :
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "../../auth/[...nextauth]/route";
import prisma from "../../../../../lib/prisma";

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.email) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
    });

    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    const { globalCategories, items } = await request.json();

    if (!Array.isArray(items)) {
      return NextResponse.json(
        { error: "Items must be an array" },
        { status: 400 }
      );
    }

    const results = [];

    for (const item of items) {
      // Validate required fields
      if (!item.phrase || !item.explanation) {
        continue; // Skip invalid items
      }

      // Process categories - merge globalCategories with item categories
      let allCategoryNames: string[] = [];
      
      // Add global categories
      if (Array.isArray(globalCategories)) {
        allCategoryNames.push(...globalCategories);
      }
      
      // Add item-specific categories
      if (Array.isArray(item.categories)) {
        allCategoryNames.push(...item.categories);
      }
      
      // Remove duplicates
      allCategoryNames = [...new Set(allCategoryNames)];

      let categoryIds: string[] = [];
      
      for (const categoryName of allCategoryNames) {
        if (typeof categoryName !== 'string') continue;
        
        let category = await prisma.category.findFirst({
          where: { 
            name: categoryName.trim(),
            userId: user.id 
          },
        });
        
        // Create category if it doesn't exist
        if (!category) {
          category = await prisma.category.create({
            data: {
              name: categoryName.trim(),
              color: getRandomColor(),
              userId: user.id,
            },
          });
        }
        
        if (category) {
          categoryIds.push(category.id);
        }
      }

      // Create the phrase
      const phrase = await prisma.medicalPhrase.create({
        data: {
          phrase: item.phrase,
          explanation: item.explanation,
          context: item.context || null,
          userId: user.id,
          categories: {
            connect: categoryIds.map(id => ({ id })),
          },
        },
        include: {
          categories: true,
        },
      });

      results.push(phrase);
    }

    return NextResponse.json({
      message: `${results.length} phrases imported successfully`,
      data: results,
    });
  } catch (error) {
    console.error("Error importing phrases:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

function getRandomColor() {
  const colors = [
    "#3B82F6", "#EF4444", "#10B981", "#F59E0B", "#8B5CF6",
    "#EC4899", "#06B6D4", "#84CC16", "#F97316", "#6366F1"
  ];
  return colors[Math.floor(Math.random() * colors.length)];
}
-----

the codes of file with route : /components/import-from-json-dialog.tsx :
"use client";
import { useState } from "react";
import { Button } from "./ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "./ui/card";
import { Input } from "./ui/input";
import { useToast } from "../hooks/use-toast";
import { motion } from "framer-motion";

interface ImportFromJsonDialogProps {
  onClose: () => void;
  onImport: () => void;
  type: "terms" | "phrases";
}

export function ImportFromJsonDialog({ onClose, onImport, type }: ImportFromJsonDialogProps) {
  const [jsonText, setJsonText] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const { toast } = useToast();

  const handleImport = async () => {
    if (!jsonText.trim()) {
      toast({
        title: "خطا",
        description: "لطفا محتوای JSON را وارد کنید",
        variant: "destructive",
      });
      return;
    }

    try {
      setIsLoading(true);
      const parsedData = JSON.parse(jsonText);

      // Support both array format and object with items + globalCategories
      const items = Array.isArray(parsedData) ? parsedData : parsedData.items;
      const globalCategories = parsedData.globalCategories;

      if (!Array.isArray(items)) {
        throw new Error("داده‌ها باید به صورت آرایه یا آبجکت با فیلد items باشند");
      }

      // Validate each item based on type
      for (const item of items) {
        if (type === "terms") {
          if (!item.term || !item.meaning) {
            throw new Error("هر اصطلاح باید دارای فیلدهای term و meaning باشد");
          }
        } else {
          if (!item.phrase || !item.explanation) {
            throw new Error("هر عبارت باید دارای فیلدهای phrase و explanation باشد");
          }
        }
      }

      // Send to API
      const response = await fetch(`/api/${type}/import`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ 
          items,
          globalCategories: Array.isArray(globalCategories) ? globalCategories : undefined 
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "خطا در وارد کردن داده‌ها");
      }

      toast({
        title: "موفق",
        description: `${items.length} ${type === "terms" ? "اصطلاح" : "عبارت"} با موفقیت وارد شد`,
      });

      onImport();
      onClose();
    } catch (error: any) {
      console.error("Error importing data:", error);
      toast({
        title: "خطا",
        description: error.message || "خطا در پردازش داده‌های JSON",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleExample = () => {
    const example = type === "terms" 
      ? JSON.stringify({
          "globalCategories": ["cardiology", "emergency"],
          "items": [
            {
              "term": "Hypertension",
              "meaning": "فشار خون بالا",
              "pronunciation": "/ˌhaɪ.pərˈten.ʃən/",
              "explanation": "شرایطی که در آن فشار خون در شریان‌ها به طور مداوم بالا است",
              "categories": ["tissues"]
            },
            {
              "term": "Tachycardia",
              "meaning": "تندتپشی",
              "pronunciation": "/tæk.ɪˈkɑːr.di.ə/",
              "explanation": "ضربان قلب سریع‌تر از حالت طبیعی"
            }
          ]
        }, null, 2)
      : JSON.stringify({
          "globalCategories": ["examination", "general"],
          "items": [
            {
              "phrase": "How are you feeling today?",
              "explanation": "حالتان امروز چطور است؟",
              "context": "پرسش معمول از بیمار درباره حال عمومی",
              "categories": ["greeting"]
            },
            {
              "phrase": "Take a deep breath",
              "explanation": "یک نفس عمیق بکشید",
              "context": "دستور به بیمار هنگام معاینه ریه"
            }
          ]
        }, null, 2);

    setJsonText(example);
  };

  const handleSimpleExample = () => {
    const example = type === "terms" 
      ? JSON.stringify([
          {
            "term": "Hypertension",
            "meaning": "فشار خون بالا",
            "categories": ["cardiology", "emergency", "tissues"]
          },
          {
            "term": "Tachycardia",
            "meaning": "تندتپشی", 
            "categories": ["cardiology", "emergency"]
          }
        ], null, 2)
      : JSON.stringify([
          {
            "phrase": "How are you feeling today?",
            "explanation": "حالتان امروز چطور است؟",
            "categories": ["general", "greeting"]
          },
          {
            "phrase": "Take a deep breath",
            "explanation": "یک نفس عمیق بکشید",
            "categories": ["examination", "general"]
          }
        ], null, 2);

    setJsonText(example);
  };

  const handleClear = () => {
    setJsonText("");
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
      <motion.div
        initial={{ opacity: 0, scale: 0.9 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.9 }}
        className="w-full max-w-4xl max-h-[90vh] overflow-hidden"
      >
        <Card className="w-full h-full flex flex-col">
          <CardHeader className="border-b bg-linear-to-r from-green-50 to-blue-50">
            <CardTitle className="text-xl flex items-center gap-2">
              📥 وارد کردن {type === "terms" ? "اصطلاحات" : "عبارات"} از JSON
            </CardTitle>
            <CardDescription>
              از globalCategories برای دسته‌بندی‌های مشترک و categories برای دسته‌بندی‌های خاص هر آیتم استفاده کنید
            </CardDescription>
          </CardHeader>
          <CardContent className="flex-1 overflow-hidden flex flex-col gap-4 p-6">
            {/* JSON Input Section */}
            <div className="space-y-3 flex-1 flex flex-col">
              <div className="flex justify-between items-center">
                <label className="text-sm font-medium">
                  محتوای JSON
                </label>
                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={handleExample}
                    className="text-xs"
                  >
                    🎯 نمونه پیشرفته
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={handleSimpleExample}
                    className="text-xs"
                  >
                    📝 نمونه ساده
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={handleClear}
                    className="text-xs"
                  >
                    🗑️ پاک کردن
                  </Button>
                </div>
              </div>
              <div className="flex-1 min-h-0">
                <textarea
                  value={jsonText}
                  onChange={(e) => setJsonText(e.target.value)}
                  placeholder={`// دو روش برای تعیین دسته‌بندی:\n// 1. استفاده از globalCategories + categories\n// 2. فقط استفاده از categories در هر آیتم\n\n{\n  "globalCategories": ["دسته‌مشترک1", "دسته‌مشترک2"],\n  "items": [\n    {\n      "${type === "terms" ? "term" : "phrase"}": "...",\n      "${type === "terms" ? "meaning" : "explanation"}": "...",\n      "categories": ["دسته‌اختصاصی"]\n    }\n  ]\n}`}
                  className="w-full h-full p-4 border border-gray-300 rounded-lg resize-none font-mono text-sm leading-relaxed"
                  dir="ltr"
                />
              </div>
            </div>

            {/* Instructions Section */}
            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
              <h4 className="font-medium text-blue-800 mb-3 flex items-center gap-2">
                💡 راهنمای فرمت JSON
              </h4>
              <div className="grid md:grid-cols-2 gap-4 text-sm">
                <div>
                  <h5 className="font-medium text-blue-700 mb-2">ساختارهای پشتیبانی شده:</h5>
                  <ul className="text-blue-600 space-y-1 list-disc list-inside">
                    <li><strong>آرایه ساده</strong> - فقط با فیلد categories</li>
                    <li><strong>آبجکت پیشرفته</strong> - با globalCategories + items</li>
                  </ul>
                </div>
                <div>
                  <h5 className="font-medium text-blue-700 mb-2">منطق دسته‌بندی‌ها:</h5>
                  <ul className="text-blue-600 space-y-1 list-disc list-inside">
                    <li><code>globalCategories</code> + <code>categories</code> = ادغام می‌شوند</li>
                    <li>دسته‌بندی‌های تکراری حذف می‌شوند</li>
                    <li>دسته‌بندی‌های جدید به طور خودکار ایجاد می‌شوند</li>
                  </ul>
                </div>
              </div>
              
              {/* Example Preview */}
              <div className="mt-4 space-y-3">
                <h6 className="font-medium text-gray-700 mb-2">نمونه‌های معادل:</h6>
                <div className="grid md:grid-cols-2 gap-3">
                  <div className="p-3 bg-white rounded border">
                    <h6 className="text-xs font-medium text-gray-600 mb-1">روش پیشرفته:</h6>
                    <pre className="text-xs text-gray-600 overflow-x-auto">
{`{
  "globalCategories": ["A", "B"],
  "items": [
    {
      "term": "X",
      "meaning": "...",
      "categories": ["C"]
    }
  ]
}`}
                    </pre>
                    <p className="text-xs text-gray-500 mt-1">← دسته‌بندی‌ها: A, B, C</p>
                  </div>
                  <div className="p-3 bg-white rounded border">
                    <h6 className="text-xs font-medium text-gray-600 mb-1">روش ساده:</h6>
                    <pre className="text-xs text-gray-600 overflow-x-auto">
{`[
  {
    "term": "X", 
    "meaning": "...",
    "categories": ["A", "B", "C"]
  }
]`}
                    </pre>
                    <p className="text-xs text-gray-500 mt-1">← دسته‌بندی‌ها: A, B, C</p>
                  </div>
                </div>
              </div>
            </div>

            {/* Action Buttons */}
            <div className="flex gap-3 justify-end pt-4 border-t">
              <Button
                variant="outline"
                onClick={onClose}
                disabled={isLoading}
                className="min-w-24"
              >
                لغو
              </Button>
              <Button
                onClick={handleImport}
                disabled={isLoading || !jsonText.trim()}
                className="bg-green-600 hover:bg-green-700 min-w-32 shadow-lg transition-all duration-200 hover:scale-105"
              >
                {isLoading ? (
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                    <span>در حال وارد کردن...</span>
                  </div>
                ) : (
                  `📥 وارد کردن ${type === "terms" ? "اصطلاحات" : "عبارات"}`
                )}
              </Button>
            </div>
          </CardContent>
        </Card>
      </motion.div>
    </div>
  );
}
-----
[/file content end]